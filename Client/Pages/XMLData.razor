@page "/xmldata"
@using DominosCutScreen.Client.Components
@using DominosCutScreen.Shared
@using System.Xml.Serialization;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Diagnostics.CodeAnalysis;
@implements IDisposable
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http

<PageTitle>XML Data</PageTitle>

<div class="my-1">
    <button @onclick="@(async e => { showAllOrders = true; await InvokeAsync(StateHasChanged); })">Show All Orders</button>
    <button @onclick="@(async e => { showAllOrders = false; await InvokeAsync(StateHasChanged); })">Trim Orders</button>
</div>

<div class="d-grid">
    <div class="d-flex flex-row overflow-auto hideScollBar">
    @{
        // Order by max bump time to the order that was bumped first will be first.
        IEnumerable<MakeLineOrder> orders = Orders.OrderBy(o => o.Items.Max(i => i.BumpedTimes.Max()));

        if (!showAllOrders)
        {
            orders = orders.Where(o => o.IsBumped && !CutBumpedOrders.Contains(o.OrderNumber) && (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) <= TimeSpan.FromSeconds(OvenTime + GraceTime));
        }
    }
    @foreach (var order in orders)
    {
        <Order MakelineOrder=order OnClicked=OnOrderClicked />
    }
    </div>
</div>

@code {
    private System.Timers.Timer FetchTimer = new ();
    private List<MakeLineOrder> Orders = new();
    private List<MakeLineOrderItemHistory> BumpHistory = new();
    private List<int> CutBumpedOrders = new();
    private bool showAllOrders = false;

    /// <summary>
    /// How long is the oven time in seconds
    /// </summary>
    private const int OvenTime = 300;

    /// <summary>
    /// How long should orders stay on the screen once they have been bumped for <see cref="OvenTime">
    /// </summary>
    private const int GraceTime = 30;

    protected override async Task OnInitializedAsync()
    {
        await GetData();

        FetchTimer.AutoReset = true;
        FetchTimer.Interval = 5000;
        FetchTimer.Elapsed += async (object? sender, System.Timers.ElapsedEventArgs e) =>
        {
            await GetData();
        };
        FetchTimer.Start();
    }

    protected async Task GetData()
    {
        var newBumpHistory = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrderItemHistory>>("api/Makeline/bump");
        if (newBumpHistory != null)
        {
            BumpHistory = newBumpHistory.ToList();
        }

        var newOrders = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrder>>("api/Makeline/orders");
        if (newOrders != null)
        {
            Orders.AddRange(newOrders);
            Orders = Orders.Distinct().ToList();
        }

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        FetchTimer?.Dispose();
    }

    private void OnOrderClicked(MakeLineOrder Order)
    {
        CutBumpedOrders.Add(Order.OrderNumber);
    }
}
