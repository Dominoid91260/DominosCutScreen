@page "/xmldata"
@using DominosCutScreen.Shared
@using System.Xml.Serialization;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Diagnostics.CodeAnalysis;
@implements IDisposable
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http

<PageTitle>XML Data</PageTitle>

<div class="my-1">
    <button @onclick="@(async e => { showAllOrders = true; await InvokeAsync(StateHasChanged); })">Show All Orders</button>
    <button @onclick="@(async e => { showAllOrders = false; await InvokeAsync(StateHasChanged); })">Trim Orders</button>
</div>

@{
    var groupedHistory = BumpHistory.GroupBy(h => h.OrderNumber);
    var joinedData = groupedHistory.Join(Orders, g => g.Key, o => o.OrderNumber, (g, o) => new
    {
        Order = o,
        LastBumpedAt = g.Max(x => x.BumpedAtTime),
        BumpedItems = g.GroupBySequential(h => new { h.Description, h.ToppingModifications }, h => h, (x, y) => x.Description.Equals(y.Description, StringComparison.InvariantCultureIgnoreCase) && Enumerable.SequenceEqual(x.ToppingModifications, y.ToppingModifications)).Select(group => new
        {
            Item = group.FirstOrDefault(),
            Quantity = group.Count()
        })
    });
    var sortedData = joinedData.OrderBy(item => item.LastBumpedAt);

    <div class="d-flex flex-row">
        @foreach (var item in sortedData.Where(x => showAllOrders ? true : (DateTime.Now - x.LastBumpedAt) <= TimeSpan.FromSeconds(OvenTime + GraceTime)))
    {
        <div class="card mx-2" style="width: 18rem;">
            <div class="card-body">
                <h5 class="card-title">Order @item.Order.OrderNumber</h5>
                @foreach (var bumpedItem in item.BumpedItems)
                {
                    //Console.WriteLine(JsonSerializer.Serialize(bumpedItem));
                    <p class="card-text m-0">@(bumpedItem.Quantity)x @bumpedItem.Item.Description

                    @foreach (var tm in bumpedItem.Item.ToppingModifications.OrderBy(t => t.DisplaySequence))
                    {
                        var color = tm.ToppingAmountCode == 45 ? "danger" : "success";

                        <br />
                        <span class="d-inline-block text-@color" style="text-indent: 1rem;">@tm.ToppingAmountDescription @tm.ToppingDescription</span>
                    }

                    </p>
                }
            </div>
            <div class="card-footer text-center">
                <small class="text-muted">@(item.Order.IsElectronic ? "Internet" : CultureInfo.CurrentCulture.TextInfo.ToTitleCase(item.Order.TakenBy.ToLower()))</small>
            </div>
        </div>
    }
    </div>
}

@code {
    private DateTime LastMakelineCheck;
    private System.Timers.Timer FetchTimer = new ();
    private MakeLineOrderItemHistory[]? BumpHistory;
    private MakeLineOrder[]? Orders;
    private bool showAllOrders = false;

    /// <summary>
    /// How long is the oven time in seconds
    /// </summary>
    private const int OvenTime = 300;

    /// <summary>
    /// How long should orders stay on the screen once they have been bumped for <see cref="OvenTime">
    /// </summary>
    private const int GraceTime = 30;

    protected override async Task OnInitializedAsync()
    {
        if (await localStorage.ContainKeyAsync("LastMakelineCheck"))
        {
            LastMakelineCheck = await localStorage.GetItemAsync<DateTime>("LastMakelineCheck");
        }
        else
        {
            // No last check date, set it to today at midnight
            LastMakelineCheck = DateTime.Now.Date;
            Console.WriteLine($"Setting LastMakelineCheck to {LastMakelineCheck}");
        }

        await GetData();
        FetchTimer.AutoReset = true;
        FetchTimer.Interval = 5000;
        FetchTimer.Elapsed += async (object? sender, System.Timers.ElapsedEventArgs e) =>
        {
            await GetData();
            await InvokeAsync(StateHasChanged);
        };
        //FetchTimer.Start();
    }

    protected async Task GetData()
    {
        BumpHistory = await Http.GetFromJsonAsync<MakeLineOrderItemHistory[]>("api/Makeline/bump");
        Orders = await Http.GetFromJsonAsync<MakeLineOrder[]>("api/Makeline/orders?Since=" + LastMakelineCheck.ToString("s", System.Globalization.CultureInfo.InvariantCulture));
        LastMakelineCheck = DateTime.Now;
        await localStorage.SetItemAsync("LastMakelineCheck", LastMakelineCheck);
    }

    public void Dispose()
    {
        FetchTimer?.Dispose();
    }


}
