@page "/xmldata"
@using DominosCutScreen.Client.Components
@using DominosCutScreen.Shared
@using System.Xml.Serialization;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Diagnostics.CodeAnalysis;
@implements IDisposable
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>XML Data</PageTitle>

<div class="my-1">
    <button @onclick="@(async e => { showAllOrders = true; await InvokeAsync(StateHasChanged); })">Show All Orders</button>
    <button @onclick="@(async e => { showAllOrders = false; await InvokeAsync(StateHasChanged); })">Trim Orders</button>
    <button @onclick=@RequestSilenceMakeline>STFU Makeline</button>
</div>

<div class="d-grid">
    <h4>Live Orders</h4>
    <div id="liveOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @{
        // Order by max bump time to the order that was bumped first will be first.
        List<MakeLineOrder> orders = Orders.Where(o => o.IsBumped).ToList();
        IEnumerable<MakeLineOrder> ongoing = new List<MakeLineOrder>();
        IEnumerable<MakeLineOrder> finished = new List<MakeLineOrder>();

        if (BumpHistory.Any())
        {
            orders.AddRange(BumpHistory.GroupBy(h => h.OrderNumber).Where(g => !orders.Any(o => o.OrderNumber == g.Key)).Select(g => new MakeLineOrder
            {
                OrderNumber = g.Key,
                TakenBy = "Reconstructed Order",
                TypeCode = g.First().TypeCode,
                Items = g.GroupBySequential(i => new { i.Description, i.ToppingModifications }, i => i, (x, y) => x.Description.Equals(y.Description, StringComparison.InvariantCultureIgnoreCase) && Enumerable.SequenceEqual(x.ToppingModifications, y.ToppingModifications))
                .Select(g => new MakeLineOrderLine{
                    Quantity = g.Count(),
                    Description = g.First().Description,
                    ToppingModifications = g.First().ToppingModifications,
                    BumpedTimes = g.Select(i => i.BumpedAtTime).ToList(),
                    PrettyItemName = g.First().PrettyItemName,
                    PizzaBaseName = g.First().PizzaBaseName
                }).ToList()
            }));
        }

        if(orders.Any())
        {
            orders = orders.OrderBy(o => o.Items.Max(i => {
                if (i.BumpedTimes.Count == 0)
                {
                    Console.WriteLine($"{o.OrderNumber} {i.Description}");
                }

                return i.BumpedTimes.Max();
            })).ToList();

            if (!showAllOrders)
            {
                ongoing = orders.Where(o => !CutBumpedOrders.Contains(o.OrderNumber) && (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) <= TimeSpan.FromSeconds(OvenTime + GraceTime));
                finished = orders.Where(o => CutBumpedOrders.Contains(o.OrderNumber) || (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) > TimeSpan.FromSeconds(OvenTime + GraceTime)).Reverse();
            }
            else
            {
                // Repurpose `ongoing` here so we dont need to wrap it all in an if statement
                ongoing = orders;
                ongoing.Reverse();
            }
        }
    }
    @foreach (var order in ongoing)
    {
        <Order @key=order.OrderNumber MakelineOrder=order OnClicked=OnOrderClicked />
    }
    </div>

    <h4>Previous Orders</h4>
    <div id="previousOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @foreach (var order in finished)
    {
        <Order @key=order.OrderNumber MakelineOrder=order />
    }
    </div>
</div>

@code {
    private System.Timers.Timer FetchTimer = new ();
    private List<MakeLineOrder> Orders = new();
    private List<MakeLineOrderItemHistory> BumpHistory = new();
    private List<int> CutBumpedOrders = new();
    private bool showAllOrders = false;

    /// <summary>
    /// How long is the oven time in seconds
    /// </summary>
    private const int OvenTime = 300;

    /// <summary>
    /// How long should orders stay on the screen once they have been bumped for <see cref="OvenTime">
    /// </summary>
    private const int GraceTime = 90;

    protected override async Task OnInitializedAsync()
    {
        await GetData();

        FetchTimer.AutoReset = true;
        FetchTimer.Interval = 5000;
        FetchTimer.Elapsed += async (object? sender, System.Timers.ElapsedEventArgs e) =>
        {
            await GetData();
        };
        FetchTimer.Start();

        await JS.InvokeVoidAsync("SetAllOrderCardProgress");
    }

    protected async Task GetData()
    {
        var newBumpHistory = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrderItemHistory>>("api/Makeline/bump");
        if (newBumpHistory != null)
        {
            BumpHistory = newBumpHistory.ToList();
        }

        var newOrders = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrder>>("api/Makeline/orders");
        if (newOrders != null)
        {
            Orders = newOrders.ToList();
        }

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        FetchTimer?.Dispose();
    }

    private void OnOrderClicked(MakeLineOrder Order)
    {
        CutBumpedOrders.Add(Order.OrderNumber);
    }

    private async Task RequestSilenceMakeline()
    {
        await Http.GetAsync("api/Makeline/silence");
    }
}
