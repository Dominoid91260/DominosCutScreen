@page "/xmldata"
@using DominosCutScreen.Client.Components
@using DominosCutScreen.Shared
@using System.Xml.Serialization;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Diagnostics.CodeAnalysis;
@implements IDisposable
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject IJSRuntime JS
@inject SettingsService Settings

@{
    // Order by max bump time to the order that was bumped first will be first.
    List<MakeLineOrder> orders = Orders.Where(o => o.IsBumped).ToList();
    IEnumerable<MakeLineOrder> ongoing = new List<MakeLineOrder>();
    IEnumerable<MakeLineOrder> finished = new List<MakeLineOrder>();

    if (BumpHistory.Any())
    {
        orders.AddRange(BumpHistory.GroupBy(h => h.OrderNumber).Where(g => !orders.Any(o => o.OrderNumber == g.Key)).Select(g => new MakeLineOrder
        {
            OrderNumber = g.Key,
            TakenBy = "Reconstructed Order",
            TypeCode = g.First().TypeCode,
            IsExpedited = g.Any(h => h.Description.Contains("Priority", StringComparison.InvariantCultureIgnoreCase)),
            Items = g.GroupBySequential(i => new { i.Description, i.ToppingModifications }, i => i, (x, y) => x.Description.Equals(y.Description, StringComparison.InvariantCultureIgnoreCase) && Enumerable.SequenceEqual(x.ToppingModifications, y.ToppingModifications))
            .Select(g => new MakeLineOrderLine{
                Quantity = g.Count(),
                Description = g.First().Description,
                ToppingModifications = g.First().ToppingModifications,
                BumpedTimes = g.Select(i => i.BumpedAtTime).ToList(),
                PrettyItemName = g.First().PrettyItemName,
                PizzaBaseName = g.First().PizzaBaseName
            }).ToList()
        }));
    }

    if(orders.Any())
    {
        orders = orders.OrderBy(o => {
            if (o.Items.Any(i => i.BumpedTimes.Count == 0))
                return o.ActualOrderedAt;
            
            return o.Items.Max(i => i.BumpedTimes.Max());
        }).ToList();

        if (!showAllOrders)
        {
            ongoing = orders.Where(o => !CutBumpedOrders.Contains(o.OrderNumber) && !PinnedOrders.Contains(o.OrderNumber) && (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) <= TimeSpan.FromSeconds(Settings.OvenTime + Settings.GraceTime));
            finished = orders.Where(o => CutBumpedOrders.Contains(o.OrderNumber) || (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) > TimeSpan.FromSeconds(Settings.OvenTime + Settings.GraceTime)).Reverse();
        }
        else
        {
            // Repurpose `ongoing` here so we dont need to wrap it all in an if statement
            ongoing = orders;
            ongoing.Reverse();
        }
    }
}

<PageTitle>XML Data</PageTitle>

<nav class="navbar navbar-expand bg-light">
    <div class="container-fluid">
        <ul class="navbar-nav flex-row">
            <li class="nav-item">
                <button class="btn btn-primary" @onclick="@(async e => { showAllOrders = true; await InvokeAsync(StateHasChanged); })">Show All Orders</button>
            </li>
            <li class="nav-itemm ms-3">
                <button class="btn btn-primary" @onclick="@(async e => { showAllOrders = false; await InvokeAsync(StateHasChanged); })">Trim Orders</button>
            </li>
            <li class="nav-item ms-3">
                <button class="btn btn-primary" @onclick=@RequestSilenceMakeline>STFU Makeline</button>
            </li>
        </ul>
    </div>
</nav>

<div class="d-grid">
    @if (PinnedOrders.Any() && orders.Any())
    {
    <h4>Pinned Orders</h4>
    <div class="d-flex flex-row overflow-auto thinScrollBar mb-4">
    @foreach (var number in PinnedOrders)
    {
        var orderNumber = number;
        var order = orders.Where(o => o.OrderNumber == orderNumber).First();
        <Order @key=orderNumber MakelineOrder=order OnReceiptClicked=OnOrderReprint OnDismissClicked=OnOrderDismissed ShowPin=false />
    }
    </div>
    }

    <h4>Live Orders</h4>
    <div id="liveOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @foreach (var order in ongoing)
    {
        <Order @key=order.OrderNumber MakelineOrder=order OnReceiptClicked=OnOrderReprint OnDismissClicked=OnOrderDismissed OnPinClicked=OnOrderPinned />
    }
    </div>

    <h4>Previous Orders</h4>
    <div id="previousOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @foreach (var order in finished)
    {
        <Order @key=order.OrderNumber MakelineOrder=order  ShowDismiss=false OnReceiptClicked=OnOrderReprint OnPinClicked=OnOrderPinned />
    }
    </div>
</div>

@code {
    private System.Timers.Timer FetchTimer = new ();
    private List<MakeLineOrder> Orders = new();
    private List<MakeLineOrderItemHistory> BumpHistory = new();
    private List<int> CutBumpedOrders = new();
    private List<int> PinnedOrders = new();
    private bool showAllOrders = false;
    private HashSet<DateTime> AlertedOrderNumbers = new();

    protected override async Task OnInitializedAsync()
    {
        await GetData();

        FetchTimer.AutoReset = true;
        FetchTimer.Interval = (int)TimeSpan.FromSeconds(Settings.FetchInterval).TotalMilliseconds;
        FetchTimer.Elapsed += async (object? sender, System.Timers.ElapsedEventArgs e) =>
        {
            await GetData();
        };
        FetchTimer.Start();

        await JS.InvokeVoidAsync("SetAllOrderCardProgress");
    }

    protected async Task GetData()
    {
        var newBumpHistory = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrderItemHistory>>("api/Makeline/bump");
        if (newBumpHistory != null)
        {
            BumpHistory = newBumpHistory.ToList();
        }

        var newOrders = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrder>>("api/Makeline/orders");
        if (newOrders != null)
        {
            // Check first order of the day
            if (Orders.Count == 0 && newOrders.Any())
            {
                // If any timed orders are due now or an ASAP internet order has come through play the sound
                if (newOrders.Any(o => (o.IsTimedOrder && o.SavedAt >= DateTime.Now) || o.IsElectronic))
                {
                    await JS.InvokeVoidAsync("playOvenAlert");
                }
            }

            Orders = newOrders.ToList();
        }
        
        var sortedBump = BumpHistory.GroupBy(h => h.BumpedAtTime).Select(g => g.Key).OrderBy(d => d).ToList();
        for (var index = 0; index < sortedBump.Count; ++index)
        {
            var currTime = sortedBump[index];
            var expectedAlertTime = currTime.AddSeconds(Settings.OvenTime);
            var cutOff = currTime.AddSeconds(Settings.OvenTime + Settings.GraceTime);

            if (!(DateTime.Now >= expectedAlertTime && DateTime.Now <= cutOff))
                continue;

            var last = (index == 0) ? DateTime.Now.Date : sortedBump[index - 1];

            if (
                (currTime - last).TotalSeconds >= Settings.AlertInterval &&
                !AlertedOrderNumbers.Contains(currTime)
                )
                {
                    AlertedOrderNumbers.Add(currTime);
                    await JS.InvokeVoidAsync("playOvenAlert");
                }
        }

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        FetchTimer?.Dispose();
    }

    private void OnOrderDismissed(MakeLineOrder Order)
    {
        PinnedOrders.Remove(Order.OrderNumber);
        CutBumpedOrders.Add(Order.OrderNumber);
    }

    private async Task OnOrderReprint(MakeLineOrder Order)
    {
        await Http.GetAsync($"api/Makeline/reprint/{Order.OrderNumber}");
    }

    private void OnOrderPinned(MakeLineOrder Order)
    {
        CutBumpedOrders.Remove(Order.OrderNumber);

        if (PinnedOrders.Contains(Order.OrderNumber))
        {
            PinnedOrders.Remove(Order.OrderNumber);
        }
        else
        {
            PinnedOrders.Add(Order.OrderNumber);
        }
    }

    private async Task RequestSilenceMakeline()
    {
        await Http.GetAsync("api/Makeline/silence");
    }
}
