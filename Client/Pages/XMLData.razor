@page "/xmldata"
@using DominosCutScreen.Client.Components
@using DominosCutScreen.Shared
@using System.Xml.Serialization;
@using System.Text.Json;
@using System.Text.Json.Serialization;
@using System.Globalization;
@using System.Diagnostics.CodeAnalysis;
@implements IDisposable
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>XML Data</PageTitle>

<div class="my-1">
    <button @onclick="@(async e => { showAllOrders = true; await InvokeAsync(StateHasChanged); })">Show All Orders</button>
    <button @onclick="@(async e => { showAllOrders = false; await InvokeAsync(StateHasChanged); })">Trim Orders</button>
    <button @onclick=@RequestSilenceMakeline>STFU Makeline</button>
</div>

<div class="d-grid">
    <h4>Live Orders</h4>
    <div id="liveOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @{
        // Order by max bump time to the order that was bumped first will be first.
        IEnumerable<MakeLineOrder> orders = Orders.Where(o => o.IsBumped).OrderBy(o => o.Items.Max(i => i.BumpedTimes.Max()));
        IEnumerable<MakeLineOrder> ongoing = new List<MakeLineOrder>();
        IEnumerable<MakeLineOrder> finished = new List<MakeLineOrder>();

        if (!showAllOrders)
        {
            ongoing = orders.Where(o => !CutBumpedOrders.Contains(o.OrderNumber) && (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) <= TimeSpan.FromSeconds(OvenTime + GraceTime));
            finished = orders.Where(o => CutBumpedOrders.Contains(o.OrderNumber) || (DateTime.Now - o.Items.Max(i => i.BumpedTimes.Max())) > TimeSpan.FromSeconds(OvenTime + GraceTime)).Reverse();
        }
        else
        {
            // Repurpose `ongoing` here so we dont need to wrap it all in an if statement
            ongoing = orders.Reverse();
        }
    }
    @foreach (var order in ongoing)
    {
        <Order MakelineOrder=order OnClicked=OnOrderClicked />
    }
    </div>

    <h4>Previous Orders</h4>
    <div id="previousOrders" class="d-flex flex-row overflow-auto thinScollBar mb-4">
    @foreach (var order in finished)
    {
        <Order MakelineOrder=order />
    }
    </div>
</div>

@code {
    private System.Timers.Timer FetchTimer = new ();
    private List<MakeLineOrder> Orders = new();
    private List<MakeLineOrderItemHistory> BumpHistory = new();
    private List<int> CutBumpedOrders = new();
    private bool showAllOrders = false;

    /// <summary>
    /// How long is the oven time in seconds
    /// </summary>
    private const int OvenTime = 300;

    /// <summary>
    /// How long should orders stay on the screen once they have been bumped for <see cref="OvenTime">
    /// </summary>
    private const int GraceTime = 30;

    protected override async Task OnInitializedAsync()
    {
        await GetData();

        FetchTimer.AutoReset = true;
        FetchTimer.Interval = 5000;
        FetchTimer.Elapsed += async (object? sender, System.Timers.ElapsedEventArgs e) =>
        {
            await GetData();
        };
        FetchTimer.Start();

        await JS.InvokeVoidAsync("SetAllOrderCardProgress");
    }

    protected async Task GetData()
    {
        var newBumpHistory = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrderItemHistory>>("api/Makeline/bump");
        if (newBumpHistory != null)
        {
            BumpHistory = newBumpHistory.ToList();
        }

        var newOrders = await Http.GetFromJsonAsync<IEnumerable<MakeLineOrder>>("api/Makeline/orders");
        if (newOrders != null)
        {
            Orders = newOrders.ToList();
        }

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        FetchTimer?.Dispose();
    }

    private void OnOrderClicked(MakeLineOrder Order)
    {
        CutBumpedOrders.Add(Order.OrderNumber);
    }

    private async Task RequestSilenceMakeline()
    {
        await Http.GetAsync("api/Makeline/silence");
    }
}
